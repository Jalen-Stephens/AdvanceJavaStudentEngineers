package dev.coms4156.project.metadetect.service;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.lenient;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import dev.coms4156.project.metadetect.db.RlsContext;
import dev.coms4156.project.metadetect.model.Image;
import dev.coms4156.project.metadetect.repository.ImageRepository;
import dev.coms4156.project.metadetect.service.errors.ForbiddenException;
import dev.coms4156.project.metadetect.service.errors.NotFoundException;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.function.Supplier;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class ImageServiceTest {

  @Mock private ImageRepository repo;
  @Mock private RlsContext rls;

  @InjectMocks private ImageService service;

  private UUID ownerId;
  private UUID otherUserId;
  private UUID imageId;

  @BeforeEach
  void setUp() {
    ownerId = UUID.randomUUID();
    otherUserId = UUID.randomUUID();
    imageId = UUID.randomUUID();

    // Lenient stubs so tests that don't traverse rls still pass without UnnecessaryStubbing.
    lenient()
      .when(rls.asUser(any(UUID.class), any(Supplier.class)))
        .thenAnswer(inv -> ((Supplier<?>) inv.getArgument(1)).get());

    lenient()
      .doAnswer(inv -> {
        ((Runnable) inv.getArgument(1)).run();
        return null;
      })
      .when(rls)
        .asUser(any(UUID.class), any(Runnable.class));
  }

  // --- helpers ---

  private static Image newImage(UUID userId) {
    Image img = new Image();
    img.setId(UUID.randomUUID());
    img.setUserId(userId);
    img.setFilename("orig.jpg");
    img.setStoragePath("images/orig.jpg");
    img.setLabels(new String[] {"a", "b"});
    img.setNote("note");
    return img;
  }

  // Mimic DB defaults on save(): id + uploaded_at generated by DB
  private static Image dbEchoSave(Image input) {
    Image out = new Image();
    out.setId(input.getId() != null ? input.getId() : UUID.randomUUID());
    out.setUserId(input.getUserId());
    out.setFilename(input.getFilename());
    out.setStoragePath(input.getStoragePath());
    out.setLabels(input.getLabels());
    out.setNote(input.getNote());
    return out;
  }

  // --- CREATE ---

  @Test
  void create_persistsWithOwnerAndFilename_andReturnsSaved() {
    when(repo.save(any(Image.class))).thenAnswer(inv -> dbEchoSave(inv.getArgument(0)));

    Image saved =
        service.create(ownerId, "file.jpg", "images/file.jpg", new String[] {"x"}, "hello");

    ArgumentCaptor<Image> captor = ArgumentCaptor.forClass(Image.class);
    verify(repo).save(captor.capture());

    Image toSave = captor.getValue();
    assertThat(toSave.getId()).isNull(); // let DB default set it
    assertThat(toSave.getUserId()).isEqualTo(ownerId);
    assertThat(toSave.getFilename()).isEqualTo("file.jpg");
    assertThat(toSave.getStoragePath()).isEqualTo("images/file.jpg");
    assertThat(toSave.getLabels()).containsExactly("x");
    assertThat(toSave.getNote()).isEqualTo("hello");

    assertThat(saved.getId()).isNotNull();
  }

  // --- READ (single) ---

  @Test
  void getById_ownerOk_returnsImage() {
    Image img = newImage(ownerId);
    when(repo.findById(imageId)).thenReturn(Optional.of(img));

    Image out = service.getById(ownerId, imageId);

    assertThat(out).isSameAs(img);
    verify(repo).findById(imageId);
  }

  @Test
  void getById_notFound_throwsNotFound() {
    when(repo.findById(imageId)).thenReturn(Optional.empty());

    assertThatThrownBy(() -> service.getById(ownerId, imageId))
      .isInstanceOf(NotFoundException.class)
        .hasMessageContaining("Image not found");

    verify(repo).findById(imageId);
  }

  @Test
  void getById_notOwner_throwsForbidden() {
    Image img = newImage(otherUserId);
    when(repo.findById(imageId)).thenReturn(Optional.of(img));

    assertThatThrownBy(() -> service.getById(ownerId, imageId))
        .isInstanceOf(ForbiddenException.class);

    verify(repo).findById(imageId);
  }

  // --- LIST ---

  @Test
  void listByOwner_usesSortedQuery() {
    Image a = newImage(ownerId);
    Image b = newImage(ownerId);
    when(repo.findAllByUserIdOrderByUploadedAtDesc(ownerId)).thenReturn(List.of(a, b));

    List<Image> out = service.listByOwner(ownerId, 0, 5);

    assertThat(out).containsExactly(a, b);
    verify(repo).findAllByUserIdOrderByUploadedAtDesc(ownerId);
  }

  // --- UPDATE ---

  @Test
  void update_noChanges_keepsOriginalValues() {
    Image img = newImage(ownerId);
    when(repo.findById(imageId)).thenReturn(Optional.of(img));
    when(repo.save(any(Image.class))).thenAnswer(inv -> inv.getArgument(0));

    Image out = service.update(ownerId, imageId, null, null, null, null);

    assertThat(out.getFilename()).isEqualTo("orig.jpg");
    assertThat(out.getStoragePath()).isEqualTo("images/orig.jpg");
    assertThat(out.getLabels()).containsExactly("a", "b");
    assertThat(out.getNote()).isEqualTo("note");

    verify(repo).findById(imageId);
    verify(repo).save(any(Image.class));
  }

  @Test
  void update_blankFilename_isIgnored_butOtherFieldsApply() {
    Image img = newImage(ownerId);
    when(repo.findById(imageId)).thenReturn(Optional.of(img));
    when(repo.save(any(Image.class))).thenAnswer(inv -> inv.getArgument(0));

    Image out = service.update(ownerId, imageId, "   ", "images/new.jpg", new String[] {"k"}, null);

    assertThat(out.getFilename()).isEqualTo("orig.jpg"); // unchanged
    assertThat(out.getStoragePath()).isEqualTo("images/new.jpg");
    assertThat(out.getLabels()).containsExactly("k");
    assertThat(out.getNote()).isEqualTo("note"); // unchanged
  }

  @Test
  void update_ownerMismatch_throwsForbidden() {
    Image img = newImage(otherUserId);
    when(repo.findById(imageId)).thenReturn(Optional.of(img));

    assertThatThrownBy(() -> service.update(ownerId, imageId, "x.jpg", null, null, null))
        .isInstanceOf(ForbiddenException.class);
  }

  @Test
  void update_notFound_throwsNotFound() {
    when(repo.findById(imageId)).thenReturn(Optional.empty());

    assertThatThrownBy(() -> service.update(ownerId, imageId, "x.jpg", null, null, null))
        .isInstanceOf(NotFoundException.class);
  }

  // --- DELETE ---

  @Test
  void delete_ownerOk_deletes() {
    Image img = newImage(ownerId);
    when(repo.findById(imageId)).thenReturn(Optional.of(img));
    doNothing().when(repo).deleteById(imageId);

    service.delete(ownerId, imageId);

    verify(repo).findById(imageId);
    verify(repo).deleteById(eq(imageId));
  }

  @Test
  void delete_notOwner_throwsForbidden_andDoesNotDelete() {
    Image img = newImage(otherUserId);
    when(repo.findById(imageId)).thenReturn(Optional.of(img));

    assertThatThrownBy(() -> service.delete(ownerId, imageId))
        .isInstanceOf(ForbiddenException.class);

    verify(repo).findById(imageId);
    verify(repo, never()).deleteById(any());
  }

  @Test
  void delete_notFound_throwsNotFound() {
    when(repo.findById(imageId)).thenReturn(Optional.empty());

    assertThatThrownBy(() -> service.delete(ownerId, imageId))
        .isInstanceOf(NotFoundException.class);

    verify(repo).findById(imageId);
    verify(repo, never()).deleteById(any());
  }
}
