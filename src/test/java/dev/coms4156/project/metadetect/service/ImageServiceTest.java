package dev.coms4156.project.metadetect.service;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import dev.coms4156.project.metadetect.db.RlsContext;
import dev.coms4156.project.metadetect.model.Image;
import dev.coms4156.project.metadetect.repository.ImageRepository;
import dev.coms4156.project.metadetect.service.errors.ForbiddenException;
import dev.coms4156.project.metadetect.service.errors.NotFoundException;
import dev.coms4156.project.metadetect.service.SupabaseStorageService;
import java.io.IOException;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.function.Supplier;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.springframework.http.MediaType;
import org.springframework.web.multipart.MultipartFile;

@MockitoSettings(strictness = Strictness.LENIENT)
@ExtendWith(MockitoExtension.class)
class ImageServiceTest {

  @Mock private ImageRepository repo;
  @Mock private RlsContext rls;
  @Mock private SupabaseStorageService storage;

  @InjectMocks private ImageService service;

  private UUID ownerId;
  private UUID otherUserId;
  private UUID imageId;

  @BeforeEach
  void setUp() {
    ownerId = UUID.randomUUID();
    otherUserId = UUID.randomUUID();
    imageId = UUID.randomUUID();

    // Lenient stubs so tests that don't traverse rls still pass without UnnecessaryStubbing.
    // RlsContext<S> supplier
    when(rls.asUser(any(UUID.class), any(Supplier.class)))
        .thenAnswer(inv -> ((Supplier<?>) inv.getArgument(1)).get());
    // RlsContext<R> runnable
    doAnswer(inv -> {
      ((Runnable) inv.getArgument(1)).run();
      return null;
    }).when(rls).asUser(any(UUID.class), any(Runnable.class));
  }

  // --- helpers ---

  private static Image newImage(UUID userId) {
    Image img = new Image();
    img.setId(UUID.randomUUID());
    img.setUserId(userId);
    img.setFilename("orig.jpg");
    img.setStoragePath("images/orig.jpg");
    img.setLabels(new String[] {"a", "b"});
    img.setNote("note");
    return img;
  }

  // Mimic DB defaults on save(): id generated by DB if null
  private static Image dbEchoSave(Image input) {
    Image out = new Image();
    out.setId(input.getId() != null ? input.getId() : UUID.randomUUID());
    out.setUserId(input.getUserId());
    out.setFilename(input.getFilename());
    out.setStoragePath(input.getStoragePath());
    out.setLabels(input.getLabels());
    out.setNote(input.getNote());
    return out;
  }

  // --- CREATE ---

  @Test
  void create_persistsWithOwnerAndFilename_andReturnsSaved() {
    when(repo.save(any(Image.class))).thenAnswer(inv -> dbEchoSave(inv.getArgument(0)));

    Image saved =
        service.create(ownerId, "file.jpg", "images/file.jpg", new String[] {"x"}, "hello");

    ArgumentCaptor<Image> captor = ArgumentCaptor.forClass(Image.class);
    verify(repo).save(captor.capture());

    Image toSave = captor.getValue();
    assertThat(toSave.getId()).isNull(); // let DB default set it
    assertThat(toSave.getUserId()).isEqualTo(ownerId);
    assertThat(toSave.getFilename()).isEqualTo("file.jpg");
    assertThat(toSave.getStoragePath()).isEqualTo("images/file.jpg");
    assertThat(toSave.getLabels()).containsExactly("x");
    assertThat(toSave.getNote()).isEqualTo("hello");

    assertThat(saved.getId()).isNotNull();
  }

  // --- READ (single) ---

  @Test
  void getById_ownerOk_returnsImage() {
    Image img = newImage(ownerId);
    when(repo.findById(imageId)).thenReturn(Optional.of(img));

    Image out = service.getById(ownerId, imageId);

    assertThat(out).isSameAs(img);
    verify(repo).findById(imageId);
  }

  @Test
  void getById_notFound_throwsNotFound() {
    when(repo.findById(imageId)).thenReturn(Optional.empty());

    assertThatThrownBy(() -> service.getById(ownerId, imageId))
      .isInstanceOf(NotFoundException.class)
        .hasMessageContaining("Image not found");

    verify(repo).findById(imageId);
  }

  @Test
  void getById_notOwner_throwsForbidden() {
    Image img = newImage(otherUserId);
    when(repo.findById(imageId)).thenReturn(Optional.of(img));

    assertThatThrownBy(() -> service.getById(ownerId, imageId))
        .isInstanceOf(ForbiddenException.class);

    verify(repo).findById(imageId);
  }

  // --- LIST ---

  @Test
  void listByOwner_usesSortedQuery() {
    Image a = newImage(ownerId);
    Image b = newImage(ownerId);
    when(repo.findAllByUserIdOrderByUploadedAtDesc(ownerId)).thenReturn(List.of(a, b));

    List<Image> out = service.listByOwner(ownerId, 0, 5);

    assertThat(out).containsExactly(a, b);
    verify(repo).findAllByUserIdOrderByUploadedAtDesc(ownerId);
  }

  @Test
  void listByOwner_invalidArgs_throwIllegalArgument() {
    assertThatThrownBy(() -> service.listByOwner(ownerId, -1, 5))
        .isInstanceOf(IllegalArgumentException.class);
    assertThatThrownBy(() -> service.listByOwner(ownerId, 0, 0))
        .isInstanceOf(IllegalArgumentException.class);
  }

  // --- UPDATE ---

  @Test
  void update_noChanges_keepsOriginalValues() {
    Image img = newImage(ownerId);
    when(repo.findById(imageId)).thenReturn(Optional.of(img));
    when(repo.save(any(Image.class))).thenAnswer(inv -> inv.getArgument(0));

    Image out = service.update(ownerId, imageId, null, null, null, null);

    assertThat(out.getFilename()).isEqualTo("orig.jpg");
    assertThat(out.getStoragePath()).isEqualTo("images/orig.jpg");
    assertThat(out.getLabels()).containsExactly("a", "b");
    assertThat(out.getNote()).isEqualTo("note");

    verify(repo).findById(imageId);
    verify(repo).save(any(Image.class));
  }

  @Test
  void update_blankFilename_isIgnored_butOtherFieldsApply() {
    Image img = newImage(ownerId);
    when(repo.findById(imageId)).thenReturn(Optional.of(img));
    when(repo.save(any(Image.class))).thenAnswer(inv -> inv.getArgument(0));

    Image out =
        service.update(ownerId, imageId, "   ", "images/new.jpg", new String[] {"k"}, null);

    assertThat(out.getFilename()).isEqualTo("orig.jpg"); // unchanged
    assertThat(out.getStoragePath()).isEqualTo("images/new.jpg");
    assertThat(out.getLabels()).containsExactly("k");
    assertThat(out.getNote()).isEqualTo("note"); // unchanged
  }

  @Test
  void update_ownerMismatch_throwsForbidden() {
    Image img = newImage(otherUserId);
    when(repo.findById(imageId)).thenReturn(Optional.of(img));

    assertThatThrownBy(() -> service.update(ownerId, imageId, "x.jpg", null, null, null))
        .isInstanceOf(ForbiddenException.class);
  }

  @Test
  void update_notFound_throwsNotFound() {
    when(repo.findById(imageId)).thenReturn(Optional.empty());

    assertThatThrownBy(() -> service.update(ownerId, imageId, "x.jpg", null, null, null))
        .isInstanceOf(NotFoundException.class);
  }

  // --- DELETE ---

  @Test
  void delete_ownerOk_deletes() {
    Image img = newImage(ownerId);
    when(repo.findById(imageId)).thenReturn(Optional.of(img));
    doNothing().when(repo).deleteById(imageId);

    service.delete(ownerId, imageId);

    verify(repo).findById(imageId);
    verify(repo).deleteById(eq(imageId));
  }

  @Test
  void delete_notOwner_throwsForbidden_andDoesNotDelete() {
    Image img = newImage(otherUserId);
    when(repo.findById(imageId)).thenReturn(Optional.of(img));

    assertThatThrownBy(() -> service.delete(ownerId, imageId))
        .isInstanceOf(ForbiddenException.class);

    verify(repo).findById(imageId);
    verify(repo, never()).deleteById(any());
  }

  @Test
  void delete_notFound_throwsNotFound() {
    when(repo.findById(imageId)).thenReturn(Optional.empty());

    assertThatThrownBy(() -> service.delete(ownerId, imageId))
        .isInstanceOf(NotFoundException.class);

    verify(repo).findById(imageId);
    verify(repo, never()).deleteById(any());
  }

  // === NEW BRANCH COVERAGE TESTS ===

  @Test
  void upload_happyPath_setsStoragePathAndSaves() throws Exception {
    UUID newId = UUID.randomUUID();

    // 1) First save (create) -> DB assigns id
    when(repo.save(any(Image.class))).thenAnswer(inv -> {
      Image in = inv.getArgument(0);
      Image out = new Image();
      // simulate DB-generated id on first save
      out.setId(in.getId() == null ? newId : in.getId());
      out.setUserId(in.getUserId());
      out.setFilename(in.getFilename());
      out.setStoragePath(in.getStoragePath());
      out.setLabels(in.getLabels());
      out.setNote(in.getNote());
      return out;
    });

    // 2) findById during update()
    Image found = new Image();
    found.setId(newId);
    found.setUserId(ownerId);
    found.setFilename("pic.png");
    when(repo.findById(newId)).thenReturn(Optional.of(found));

    // 3) storage upload returns a value (method is non-void)
    when(storage.uploadObject(any(byte[].class), eq("image/png"),
      anyString(), eq("jwt"))).thenReturn("ok");

    // Execute
    MultipartFile file = new org.springframework.mock.web.MockMultipartFile(
        "file", "pic.png", "image/png", "DATA".getBytes());
    Image result = service.upload(ownerId, "jwt", file);

    String expectedKey = ownerId + "/" + newId + "--pic.png";
    assertThat(result.getId()).isEqualTo(newId);
    assertThat(result.getUserId()).isEqualTo(ownerId);
    assertThat(result.getFilename()).isEqualTo("pic.png");
    assertThat(result.getStoragePath()).isEqualTo(expectedKey);

    // Verify storage called with correct key/content-type
    verify(storage).uploadObject(any(byte[].class), eq("image/png"),
        eq(expectedKey), eq("jwt"));

    // Verify two saves: create (no storagePath yet) then update (with storagePath)
    org.mockito.ArgumentCaptor<Image> saveCap = org.mockito.ArgumentCaptor.forClass(Image.class);
    verify(repo, org.mockito.Mockito.times(2)).save(saveCap.capture());

    java.util.List<Image> saves = saveCap.getAllValues();
    Image first = saves.get(0);
    Image second = saves.get(1);

    // First save: creating row; id may be null going in, storagePath should be null
    assertThat(first.getUserId()).isEqualTo(ownerId);
    assertThat(first.getFilename()).isEqualTo("pic.png");
    assertThat(first.getStoragePath()).isNull();

    // Second save: update with storage path
    assertThat(second.getUserId()).isEqualTo(ownerId);
    assertThat(second.getFilename()).isEqualTo("pic.png");
    assertThat(second.getStoragePath()).isEqualTo(expectedKey);
  }


  @Test
  void upload_nullContentType_defaultsToOctetStream() throws Exception {
    UUID newId = UUID.randomUUID();

    when(repo.save(any(Image.class))).thenAnswer(inv -> {
      Image in = inv.getArgument(0);
      Image out = dbEchoSave(in);
      if (in.getId() == null) {
        out.setId(newId);
      }
      return out;
    });

    Image found = new Image();
    found.setId(newId);
    found.setUserId(ownerId);
    found.setFilename("pic.bin");
    when(repo.findById(newId)).thenReturn(Optional.of(found));

    ArgumentCaptor<String> contentTypeCap = ArgumentCaptor.forClass(String.class);
    when(storage.uploadObject(any(byte[].class),
        contentTypeCap.capture(), anyString(), anyString()))
        .thenReturn("ok");

    MultipartFile file = new org.springframework.mock.web.MockMultipartFile(
        "file", "pic.bin", null, "DATA".getBytes());

    service.upload(ownerId, "jwt", file);

    assertThat(contentTypeCap.getValue()).isEqualTo(MediaType.APPLICATION_OCTET_STREAM_VALUE);
  }

  @Test
  void upload_fileBytesThrowIoException_bubblesUp() throws Exception {
    // Service calls repo.save() BEFORE file.getBytes()
    UUID newId = UUID.randomUUID();
    when(repo.save(any(Image.class))).thenAnswer(inv -> {
      Image in = inv.getArgument(0);
      Image out = new Image();
      out.setId(newId);                      // <- ensure non-null id
      out.setUserId(in.getUserId());
      out.setFilename(in.getFilename());
      return out;
    });

    MultipartFile bad = org.mockito.Mockito.mock(MultipartFile.class);
    when(bad.getOriginalFilename()).thenReturn("x.png");
    when(bad.getContentType()).thenReturn("image/png");
    when(bad.getBytes()).thenThrow(new java.io.IOException("read fail"));

    assertThatThrownBy(() -> service.upload(ownerId, "jwt", bad))
        .isInstanceOf(java.io.IOException.class);
  }

  @Test
  void getSignedUrl_noStoragePath_throwsNotFound() {
    Image img = new Image();
    img.setId(imageId);
    img.setUserId(ownerId);
    img.setFilename("f.png");
    img.setStoragePath(null);
    when(repo.findById(imageId)).thenReturn(Optional.of(img));

    assertThatThrownBy(() -> service.getSignedUrl(ownerId, "jwt", imageId))
        .isInstanceOf(NotFoundException.class);
  }

  @Test
  void deleteAndPurge_withStoragePath_deletesStorageThenDb() {
    Image img = new Image();
    img.setId(imageId);
    img.setUserId(ownerId);
    img.setFilename("f.png");
    img.setStoragePath("owner/" + imageId + "--f.png");
    when(repo.findById(imageId)).thenReturn(Optional.of(img));

    doNothing().when(storage).deleteObject(eq(img.getStoragePath()), eq("jwt"));
    doNothing().when(repo).deleteById(imageId);

    service.deleteAndPurge(ownerId, "jwt", imageId);

    verify(storage).deleteObject(eq(img.getStoragePath()), eq("jwt"));
    verify(repo).deleteById(imageId);
  }

  @Test
  void deleteAndPurge_noStoragePath_skipsStorageDelete() {
    Image img = new Image();
    img.setId(imageId);
    img.setUserId(ownerId);
    img.setFilename("f.png");
    img.setStoragePath("   "); // blank
    when(repo.findById(imageId)).thenReturn(Optional.of(img));

    doNothing().when(repo).deleteById(imageId);

    service.deleteAndPurge(ownerId, "jwt", imageId);

    verify(storage, never()).deleteObject(anyString(), anyString());
    verify(repo).deleteById(imageId);
  }

  @Test
  void deleteAndPurge_storageDeleteFails_doesNotDeleteDb() {
    Image img = new Image();
    img.setId(imageId);
    img.setUserId(ownerId);
    img.setFilename("f.png");
    img.setStoragePath("owner/" + imageId + "--f.png");
    when(repo.findById(imageId)).thenReturn(Optional.of(img));

    doThrow(new RuntimeException("storage down"))
      .when(storage).deleteObject(eq(img.getStoragePath()), eq("jwt"));

    assertThatThrownBy(() -> service.deleteAndPurge(ownerId, "jwt", imageId))
        .isInstanceOf(RuntimeException.class)
        .hasMessageContaining("storage down");

    verify(repo, never()).deleteById(any());
  }

  @Test
  void getSignedUrl_happyPath_returnsSignedUrl() {
    UUID imgId = UUID.randomUUID();
    String key = ownerId + "/" + imgId + "--pic.png";

    Image img = new Image();
    img.setId(imgId);
    img.setUserId(ownerId);
    img.setFilename("pic.png");
    img.setStoragePath(key);
    when(repo.findById(imgId)).thenReturn(Optional.of(img));

    when(storage.createSignedUrl(eq(key), eq("jwt"))).thenReturn("https://signed.example/url");

    String url = service.getSignedUrl(ownerId, "jwt", imgId);

    assertThat(url).isEqualTo("https://signed.example/url");
    verify(storage).createSignedUrl(eq(key), eq("jwt"));
  }

  @Test
  void getSignedUrl_blankStoragePath_throwsNotFound() {
    UUID imgId = UUID.randomUUID();
    Image img = new Image();
    img.setId(imgId);
    img.setUserId(ownerId);
    img.setFilename("f.png");
    img.setStoragePath("   "); // blank triggers NotFound
    when(repo.findById(imgId)).thenReturn(Optional.of(img));

    assertThatThrownBy(() -> service.getSignedUrl(ownerId, "jwt", imgId))
        .isInstanceOf(NotFoundException.class);
  }

  @Test
  void update_setsFilenameAndNote_whenProvided() {
    Image img = newImage(ownerId);
    when(repo.findById(imageId)).thenReturn(Optional.of(img));
    when(repo.save(any(Image.class))).thenAnswer(inv -> inv.getArgument(0));

    Image out = service.update(ownerId, imageId,
        "renamed.jpg",   // filename non-blank branch
        null,            // storagePath unchanged
        null,            // labels unchanged
        "new-note");     // note non-null branch

    assertThat(out.getFilename()).isEqualTo("renamed.jpg");
    assertThat(out.getNote()).isEqualTo("new-note");
    assertThat(out.getStoragePath()).isEqualTo("images/orig.jpg");
    assertThat(out.getLabels()).containsExactly("a", "b");
  }

  @Test
  void deleteAndPurge_nullStoragePath_skipsStorageDelete() {
    Image img = new Image();
    img.setId(imageId);
    img.setUserId(ownerId);
    img.setFilename("f.png");
    img.setStoragePath(null); // explicit null branch
    when(repo.findById(imageId)).thenReturn(Optional.of(img));

    doNothing().when(repo).deleteById(imageId);

    service.deleteAndPurge(ownerId, "jwt", imageId);

    verify(storage, never()).deleteObject(anyString(), anyString());
    verify(repo).deleteById(imageId);
  }

}
